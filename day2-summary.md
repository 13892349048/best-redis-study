# Day 2 学习总结：核心数据结构与业务建模

## 📚 学习目标达成情况

✅ **目标**: 用 String/Hash/List/Set/ZSet 建模 5 个典型场景  
✅ **理论要点**: 底层编码优化、大Key风险识别、热Key处理策略  
✅ **实操**: 5个业务场景实现、Key设计规范、TTL策略制定  
✅ **验收标准**: 完成可运行的Go示例，提供Key设计与TTL策略  

## 🎯 5个典型业务场景实现

### 1. 计数器场景 (String类型)

**使用场景**: 页面PV/UV统计、点赞数、库存管理、API调用次数

**Key设计规范**:
```
{业务}:{资源类型}:{资源ID}:{指标}
stats:page:home:pv          # 页面访问量
social:post:12345:likes     # 帖子点赞数
inventory:product:iphone15:stock  # 商品库存
```

**核心命令**:
- `INCR/DECR`: 原子性自增/自减
- `INCRBY/DECRBY`: 指定步长增减
- `SET key value EX seconds`: 设置值和过期时间

**TTL策略**:
- 统计数据: 按业务周期设置 (日统计24小时，周统计7天)
- 库存数据: 不设过期时间，持久化存储
- 临时计数: 根据业务需求设置合理过期时间

### 2. 去重集场景 (Set类型)

**使用场景**: 每日签到、IP黑名单、文章标签、访客去重、权限管理

**Key设计规范**:
```
checkin:daily:2024-01-15    # 按日期分片的签到
security:ip_blacklist       # 全局黑名单
content:article:999:tags    # 文章标签集合
```

**核心命令**:
- `SADD`: 添加成员到集合
- `SISMEMBER`: 检查成员是否存在
- `SCARD`: 获取集合大小
- `SINTER/SUNION/SDIFF`: 集合运算

**TTL策略**:
- 时间维度数据: 按日期/周期自动过期
- 永久配置: 无需过期 (黑名单、权限等)
- 业务标签: 跟随主数据生命周期

### 3. 排行榜场景 (ZSet类型)

**使用场景**: 游戏积分榜、热门文章、商品销量、学生成绩

**Key设计规范**:
```
ranking:game:weekly         # 游戏周榜
ranking:articles:daily      # 文章日榜  
ranking:products:monthly    # 商品月榜
```

**核心命令**:
- `ZADD`: 添加成员和分数
- `ZINCRBY`: 增加分数
- `ZREVRANGE`: 获取排行榜 (高到低)
- `ZRANK/ZREVRANK`: 获取成员排名
- `ZRANGEBYSCORE`: 按分数范围查询

**TTL策略**:
- 实时榜: 较短过期时间 (1-24小时)
- 历史榜: 较长保存时间 (7-30天)
- 永久记录: 重要排行榜可持久化

### 4. 会话管理场景 (Hash类型)

**使用场景**: 用户会话、购物车、表单草稿、用户偏好设置

**Key设计规范**:
```
session:user:12345          # 用户会话信息
cart:user:12345            # 用户购物车
draft:form:contact:user123  # 表单草稿
```

**核心命令**:
- `HSET/HGET`: 设置/获取单个字段
- `HMSET/HMGET`: 批量设置/获取字段
- `HDEL`: 删除字段
- `HLEN`: 获取字段数量
- `HSCAN`: 分页获取字段 (大Hash时使用)

**TTL策略**:
- 会话数据: 30分钟无活动过期
- 购物车: 24小时-7天
- 草稿数据: 1-3天
- 偏好设置: 长期保存或跟随用户生命周期

### 5. 任务队列场景 (List类型)

**使用场景**: 异步任务、邮件队列、图片处理、数据同步

**Key设计规范**:
```
queue:email                 # 邮件发送队列
queue:image_process         # 图片处理队列
queue:data_sync            # 数据同步队列
```

**核心命令**:
- `LPUSH/RPUSH`: 从左/右端添加元素
- `LPOP/RPOP`: 从左/右端移除元素
- `BLPOP/BRPOP`: 阻塞式弹出 (避免轮询)
- `LLEN`: 获取队列长度
- `LRANGE`: 查看队列内容 (不消费)

**队列模式**:
- FIFO队列: `LPUSH` + `RPOP`
- 优先级队列: 高优先级`LPUSH`，普通`RPUSH`
- 阻塞消费: 生产环境使用`BRPOP`避免轮询

**TTL策略**:
- 一般不设置过期时间，确保任务不丢失
- 特殊情况下设置较长过期时间作为兜底

## ⚠️ 大Key与热Key风险识别

### 大Key识别与风险

**什么是大Key**:
- Hash: 字段数量 > 1000 或单个字段值 > 10KB
- List: 元素数量 > 1000
- Set: 成员数量 > 1000  
- ZSet: 成员数量 > 1000
- String: 值大小 > 10MB

**大Key风险**:
- 操作阻塞: O(N)命令执行时间长
- 内存占用: 单个Key占用过多内存
- 网络传输: 数据传输时间长
- 过期/删除: 可能导致Redis短暂阻塞

**解决方案**:
- 使用`SCAN`系列命令分页获取
- 拆分大Key为多个小Key
- 异步分批处理
- 设置合理的客户端超时时间

### 热Key识别与处理

**识别方法**:
- 监控`SLOWLOG`和`INFO commandstats`
- 使用`redis-cli --hotkeys` (Redis 4.0.1+)
- 客户端统计访问频率
- 监控服务器CPU和网络指标

**处理策略**:
- 本地缓存: 减少Redis访问频率
- 读写分离: 读请求路由到从库
- 数据分片: 避免热点集中在单个节点
- 限流措施: 防止突发访问压垮Redis

## 💡 Key设计最佳实践

### 1. 命名规范

```bash
# 推荐格式: {业务}:{资源类型}:{资源ID}:{指标/动作}
user:profile:12345:info         # 用户资料
order:detail:20240115001:items  # 订单明细
cache:api:user:12345           # API缓存
```

### 2. 分片策略

**时间分片**:
```bash
stats:daily:2024-01-15         # 按日分片
ranking:weekly:2024-w03        # 按周分片
log:monthly:2024-01           # 按月分片
```

**用户分片**:
```bash
cart:user:12345               # 按用户ID
session:app:mobile:user:123   # 按应用类型+用户
```

**业务分片**:
```bash
cache:product:category:1       # 按分类
queue:priority:high           # 按优先级
```

### 3. TTL策略制定

| 数据类型 | 推荐TTL | 说明 |
|---------|---------|------|
| 会话数据 | 30分钟-2小时 | 根据用户活跃度 |
| 缓存数据 | 5分钟-1小时 | 根据数据更新频率 |
| 统计数据 | 1天-7天 | 根据统计周期 |
| 临时数据 | 1小时-1天 | 根据业务需求 |
| 队列数据 | 不设置 | 确保任务不丢失 |
| 配置数据 | 不设置或很长 | 手动清理 |

## 🔧 底层编码优化要点

### 1. String编码类型

- `int`: 数值类型，内存占用最小
- `embstr`: 短字符串(<= 44字节)，一次内存分配
- `raw`: 长字符串，两次内存分配

**优化建议**:
- 数值数据优先使用数值类型
- 短字符串避免拼接，保持embstr编码

### 2. Hash编码类型

- `ziplist`: 少量字段时使用，内存紧凑
- `hashtable`: 字段较多时自动转换

**配置参数**:
```conf
hash-max-ziplist-entries 512   # ziplist最大字段数
hash-max-ziplist-value 64      # ziplist最大值长度
```

### 3. List编码类型

- `quicklist`: Redis 3.2+默认编码
- 结合ziplist和双向链表的优点

### 4. Set编码类型

- `intset`: 整数且元素较少时使用
- `hashtable`: 字符串或元素较多时使用

### 5. ZSet编码类型

- `ziplist`: 元素较少时使用
- `skiplist` + `hashtable`: 元素较多时使用

## 📊 性能基准测试结果

### 执行时间对比 (1000个字段的Hash)

| 操作 | 执行时间 | 说明 |
|------|---------|------|
| 创建1000字段 | ~34ms | 批量HSET操作 |
| HGETALL | ~385μs | 获取所有字段 (危险) |
| HSCAN分页 | ~519μs | 推荐的安全方式 |

**结论**: HSCAN虽然稍慢，但避免了阻塞风险，是大Hash的推荐操作方式。

## 🎖️ 复盘问题与答案

### Q1: 何为大Key/热Key？如何拆分与旁路？

**大Key定义**: 
- 单个Key占用内存过大 (>10MB) 或元素过多 (>1000)
- 操作耗时过长，影响Redis性能

**热Key定义**:
- 访问频率极高的Key，成为系统瓶颈
- 可能导致单点热点问题

**拆分策略**:
```bash
# 原大Key
user:12345:friends          # 包含10000个好友

# 拆分后
user:12345:friends:0        # 第1批 (0-999)
user:12345:friends:1        # 第2批 (1000-1999)
user:12345:friends:meta     # 元数据 (总数、分片信息)
```

**旁路策略**:
- 本地缓存减少Redis访问
- 读写分离分散热点
- CDN缓存静态热点数据
- 限流熔断保护机制

### Q2: 不同数据结构的选择原则？

| 需求场景 | 数据结构 | 原因 |
|---------|----------|------|
| 简单计数 | String | 原子操作，性能最优 |
| 去重需求 | Set | 天然去重，支持集合运算 |
| 排序需求 | ZSet | 自动排序，范围查询高效 |
| 对象存储 | Hash | 结构化存储，字段级更新 |
| 队列需求 | List | 双端操作，支持阻塞 |

### Q3: TTL设置的考虑因素？

1. **数据更新频率**: 频繁更新的数据设置较短TTL
2. **业务重要性**: 重要数据可以不设置TTL
3. **存储成本**: 平衡内存使用和数据完整性
4. **访问模式**: 冷数据设置较短TTL
5. **系统容量**: 根据Redis内存限制调整

## 📋 下一步计划

### Day 3 目标: 高级结构 (Bitmap/HyperLogLog/Geo)
- [ ] 掌握Bitmap位操作和用户活跃统计
- [ ] 学习HyperLogLog基数统计和误差控制
- [ ] 实现Geo地理位置服务和附近搜索
- [ ] 对比不同数据结构的适用场景

### 准备工作
- [ ] 准备用户活跃数据集
- [ ] 设计地理位置业务场景
- [ ] 搭建HyperLogLog误差测试环境

---

**Day 2 总结**: 成功实现了5个典型业务场景的Redis建模，掌握了Key设计规范和TTL策略，理解了大Key/热Key的风险与处理方案。为Day 3的高级数据结构学习打下了坚实基础。 

HSCAN比HGETALL慢是正常的，因为：
更多网络往返
更多Redis内部开销
非连续内存访问
但HSCAN的价值在于：
保持Redis响应性 ⭐⭐⭐⭐⭐
内存使用可控
可中断和恢复

在生产环境中，服务可用性比单次操作速度更重要，这就是为什么推荐HSCAN的核心原因。